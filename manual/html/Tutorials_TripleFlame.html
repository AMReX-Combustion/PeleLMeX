<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A simple triple flame &mdash; PeleLMeX 22.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/theme.css?v=df66b05f" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=d09052ea"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Backward facing step anchored premixed flame" href="Tutorials_BFSFlame.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PeleLMeX
              <img src="_static/swirlH2Fast_OH_vort_256.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Theory:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Model.html">The <cite>PeleLMeX</cite> Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="Implementation.html">Source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Validation.html">PeleLMeX Verification &amp; Validations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Performances.html">Performances</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Usage:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="LMeXControls.html">PeleLMeX controls</a></li>
<li class="toctree-l1"><a class="reference internal" href="Troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Tutorials.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Tutorials_HotBubble.html">Rising light bubble</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tutorials_FlameSheet.html">Premixed flame sheet with harmonic perturbations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tutorials_FlowPastCyl.html">Non-reacting flow past a cylinder</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tutorials_BFSFlame.html">Backward facing step anchored premixed flame</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A simple triple flame</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-your-environment">Setting-up your environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#test-case-and-boundary-conditions">Test case and boundary conditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#problem-specifications">Problem specifications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initial-solution">Initial solution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#numerical-scheme">Numerical scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-executable">Building the executable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-transient-phase">Initial transient phase</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#first-step-the-initial-solution">First step: the initial solution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-problem-on-a-coarse-grid">Running the problem on a coarse grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#steady-state-problem-activating-the-flame-control">Steady-state problem: activating the flame control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#refinement-of-the-computation">Refinement of the computation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PeleLMeX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="Tutorials.html">Tutorials</a></li>
      <li class="breadcrumb-item active">A simple triple flame</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Tutorials_TripleFlame.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="a-simple-triple-flame">
<span id="sec-tutorialtf"></span><h1>A simple triple flame<a class="headerlink" href="#a-simple-triple-flame" title="Link to this heading"></a></h1>
<section id="introduction">
<span id="sec-tuto-tf-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Laminar flames have the potential to reveal the fundamental structure of combustion
without the added complexities of turbulence.
They also aid in our understanding of the more complex turbulent flames.
Depending on the fuel involved and the flow configuration, the laminar flames can take on a number of interesting geometries.
For example, as practical combustion systems often operate in partially premixed mode,
with one or more fuel injections, a wide range of fresh gas compositions can be observed;
and these conditions favor the appearance of edge flames, see <a class="reference internal" href="#tripleflameintro"><span class="std std-numref">Fig. 21</span></a>.</p>
<figure class="align-center" id="tripleflameintro" style="width: 95%">
<img alt="_images/TF_Intro.png" src="_images/TF_Intro.png" />
<figcaption>
<p><span class="caption-number">Fig. 21 </span><span class="caption-text">: Normalized heat release rate (top) and temperature (bottom) contours of two-dimensional (2D) laminar lifted flames of ethylene.</span><a class="headerlink" href="#tripleflameintro" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Edge flames are composed of lean and rich premixed flame wings usually surrounding a central
anchoring diffusion flame extending from a single point <a class="reference internal" href="#pci2007" id="id1"><span>[PCI2007]</span></a>. Edge flames play
an important role in flame stabilization, re-ignition and propagation.
Simple fuels can exhibit up to three burning branches while diesel fuel, with a low temperature combustion mode,
can exhibit up to 5 branches.</p>
<p>The goal of this <code class="docutils literal notranslate"><span class="pre">TripleFlame</span></code> tutorial is to setup a simple 2D laminar triple edge flame configuration with <cite>PeleLMeX</cite>.
This document provides step by step instructions to properly set-up the domain and boundary conditions,
construct an initial solution, and provides guidance on how to monitor and influence the initial transient to reach
a final steady-state solution.</p>
</section>
<section id="setting-up-your-environment">
<span id="sec-tuto-tf-prepstep"></span><h2>Setting-up your environment<a class="headerlink" href="#setting-up-your-environment" title="Link to this heading"></a></h2>
<p>Getting a functioning environment in which to compile and run <cite>PeleLMeX</cite> is the first step of this tutorial.
Follow the steps listed below to get to this point:</p>
<ol class="arabic">
<li><p>The first step is to get <cite>PeleLMeX</cite> and its dependencies. To do so, use a recursive <em>git clone</em>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>git clone --recursive --shallow-submodules --single-branch https://github.com/AMReX-Combustion/PeleLMeX.git
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">--shallow-submodules</span></code> and <code class="docutils literal notranslate"><span class="pre">--single-branch</span></code> flags are recommended for most users as they
substantially reduce the size of the download by skipping extraneous parts of the git history.
Developers may wish to omit these flags in order download the complete git history of PeleLMeX
and its submodules, though standard <code class="docutils literal notranslate"><span class="pre">git</span></code> commands may also be used after a shallow clone to
obtain the skipped portions if needed.</p>
</li>
<li><p>Move into the Exec folder containing your tutorial. To do so:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>cd PeleLMeX/Exec/RegTests/&lt;CaseName&gt;
</pre></div>
</div>
<p>where &lt;CaseName&gt; is the name of your tutorial, e.g. <code class="docutils literal notranslate"><span class="pre">HotBubble</span></code>, <code class="docutils literal notranslate"><span class="pre">FlameSheet</span></code>,
<code class="docutils literal notranslate"><span class="pre">EB_BackwardStepFlame</span></code>, <code class="docutils literal notranslate"><span class="pre">EB_FlowPastCylinder</span></code>, or <code class="docutils literal notranslate"><span class="pre">TripleFlame</span></code>.</p>
</li>
</ol>
<p>You’re good to go!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The makefile system is set up such that default paths are automatically set to the
submodules obtained with the recursive <em>git clone</em>, however advanced users can set their own dependencies
in the <cite>GNUmakefile</cite> for each case by updating the top-most lines as follows:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>PELE_HOME     = &lt;path_to_PeleLMeX&gt;
AMREX_HOME        = &lt;path_to_MyAMReX&gt;
AMREX_HYDRO_HOME  = &lt;path_to_MyAMReXHydro&gt;
PELE_PHYSICS_HOME = &lt;path_to_MyPelePhysics&gt;
SUNDIALS_HOME     = &lt;path_to_MySUNDIALS&gt;
</pre></div>
</div>
<p>or directly through shell environment variables (using <em>bash</em> for instance):</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>export PELE_HOME=&lt;path_to_PeleLMeX&gt;
export AMREX_HOME=&lt;path_to_MyAMReX&gt;
export AMREX_HYDRO_HOME=&lt;path_to_MyAMReXHydro&gt;
export PELE_PHYSICS_HOME=&lt;path_to_MyPelePhysics&gt;
export SUNDIALS_HOME=&lt;path_to_MySUNDIALS&gt;
</pre></div>
</div>
<p>Note that using the first option will overwrite any
environment variables you might have previously defined when using this <cite>GNUmakefile</cite>.</p>
</div>
<section id="test-case-and-boundary-conditions">
<h3>Test case and boundary conditions<a class="headerlink" href="#test-case-and-boundary-conditions" title="Link to this heading"></a></h3>
<p>Direct Numerical Simulations (DNS) are performed on a 2x4 <span class="math notranslate nohighlight">\(cm^2\)</span> 2D computational domain
using a 64x128 base grid and up to 4 levels of refinement (although we will start with a lower number of levels).
The refinement ratio between each level is set to 2. With 4 levels, this means that the minimum grid size inside the reaction layer will be just below 20 <span class="math notranslate nohighlight">\(μm\)</span>.
The maximum box size is fixed at 32, and the base (level 0) grid is composed of 8 boxes,
as shown in <a class="reference internal" href="#tf-setupgeom"><span class="std std-numref">Fig. 22</span></a>.</p>
<p>Symmetric boundary conditions are used in the transverse (<span class="math notranslate nohighlight">\(x\)</span>) direction, while <code class="docutils literal notranslate"><span class="pre">Inflow</span></code> (dirichlet)
and <code class="docutils literal notranslate"><span class="pre">Outflow</span></code> (neumann) boundary conditions are used in the main flow direction (<span class="math notranslate nohighlight">\(y\)</span>). The flow goes
from bottom to top. The specificities of the <code class="docutils literal notranslate"><span class="pre">Inflow</span></code> boundary condition are explained in hereafter.</p>
<figure class="align-center" id="tf-setupgeom" style="width: 95%">
<img alt="_images/TF_SetupSketch.png" src="_images/TF_SetupSketch.png" />
<figcaption>
<p><span class="caption-number">Fig. 22 </span><span class="caption-text">: Sketch of the computational domain with level 0 box decomposition (left) and input mixture fraction profile (right).</span><a class="headerlink" href="#tf-setupgeom" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The geometry of the problem is specified in the first block of the <code class="docutils literal notranslate"><span class="pre">input.2d-regt</span></code>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- DOMAIN DEFINITION ------------------------
geometry.is_periodic = 0 0                # For each dir, 0: non-perio, 1: periodic
geometry.coord_sys   = 0                  # 0 =&gt; cart, 1 =&gt; RZ
geometry.prob_lo     = 0.0 0.0 0.0        # x_lo y_lo (z_lo)
geometry.prob_hi     = 0.02 0.04 0.0      # x_hi y_hi (z_hi)
</pre></div>
</div>
<p>The second block determines the boundary conditions. Refer to Fig <a class="reference internal" href="#tf-setupgeom"><span class="std std-numref">Fig. 22</span></a>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- BC FLAGS ---------------------------------
# Interior, Inflow, Outflow, Symmetry,
# SlipWallAdiab, NoSlipWallAdiab, SlipWallIsotherm, NoSlipWallIsotherm
peleLM.lo_bc = Symmetry Inflow            # bc in x_lo y_lo (z_lo)
peleLM.hi_bc = Symmetry Outflow           # bc in x_hi y_hi (z_hi)
</pre></div>
</div>
<p>The number of levels, refinement ratio between levels, maximum grid size as well as other related refinement parameters are set under the third block  :</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- AMR CONTROL ------------------------------
amr.n_cell          = 64 128              # Level 0 number of cells in each direction
amr.max_level       = 1                   # maximum level number allowed
amr.ref_ratio       = 2 2 2 2             # refinement ratio
amr.regrid_int      = 2                   # how often to regrid
amr.n_error_buf     = 1 1 2 2             # number of buffer cells in error est
amr.grid_eff        = 0.7                 # what constitutes an efficient grid
amr.blocking_factor = 16                  # block factor in grid generation (min box size)
amr.max_grid_size   = 32                  # max box size
</pre></div>
</div>
</section>
<section id="problem-specifications">
<span id="sec-tuto-tf-inflowspec"></span><h3>Problem specifications<a class="headerlink" href="#problem-specifications" title="Link to this heading"></a></h3>
<p>The edge flame is stabilized against an incoming mixing layer with a uniform velocity profile. The mixing
layer is prescribed using an hyperbolic tangent of mixture fraction <span class="math notranslate nohighlight">\(z\)</span> between 0 and 1,
as can be seen in <a class="reference internal" href="#tf-setupgeom"><span class="std std-numref">Fig. 22</span></a>:</p>
<div class="math notranslate nohighlight">
\[z(x) = 0.5 \Big(1 + tanh \Big( \frac{x - 0.6(x_{hi} + x_{lo})}{0.05(x_{hi} - x_{lo})} \Big) \Big)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is based on the classical elemental composition <a class="reference internal" href="#cf1990" id="id2"><span>[CF1990]</span></a>:</p>
<div class="math notranslate nohighlight">
\[z =  \frac{\beta - \beta_{ox}}{\beta_{fu} - \beta_{ox}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta\)</span> is Bilger’s coupling function, and subscript <span class="math notranslate nohighlight">\(ox\)</span> and <span class="math notranslate nohighlight">\(fu\)</span> correspond
to oxidizer and fuel streams respectively.</p>
<p>Specifying dirichlet <code class="docutils literal notranslate"><span class="pre">Inflow</span></code> conditions in <cite>PeleLMeX</cite> can seem daunting at first. But it is actually a very
flexible process. We walk the user through the details of it for the Triple Flame case just described. The files involved are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pelelmex_prob_parm.H</span></code>, assemble in a C++ struct <code class="docutils literal notranslate"><span class="pre">ProbParm</span></code> the input variables as well as other variables used in the initialization process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pelelmex_prob.cpp</span></code>, initialize and provide default values to the entries of <code class="docutils literal notranslate"><span class="pre">ProbParm</span></code> and allow the user to pass run-time value using the <cite>AMReX</cite> parser (<code class="docutils literal notranslate"><span class="pre">ParmParse</span></code>). In the present case, the parser will read the parameters in the <code class="docutils literal notranslate"><span class="pre">Problem</span></code> block:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- Problem ----------------------------------
prob.P_mean = 101325.0
prob.T_in = 300.0
prob.V_in = 0.85
prob.Zst = 0.055
</pre></div>
</div>
</li>
<li><p>finally, <code class="docutils literal notranslate"><span class="pre">pelelmex_prob.H</span></code> contains the <code class="docutils literal notranslate"><span class="pre">pelelmex_initdata</span></code> and <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> functions responsible for generating the initial and boundary conditions, resspectively.</p></li>
</ul>
<p>Note that in our specific case, we compute the input value of the mass fractions (Y) <em>directly</em> in <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code>,
using the <code class="docutils literal notranslate"><span class="pre">ProbParm</span></code> variables. We do not need any additional information, because we hard coded the hyperbolic
tangent profile of <span class="math notranslate nohighlight">\(z\)</span> (see previous formula) and there is a direct relation with the mass fraction profiles.
The interested reader can look at the function <code class="docutils literal notranslate"><span class="pre">set_Y_from_Ksi</span></code> and <code class="docutils literal notranslate"><span class="pre">set_Y_from_Phi</span></code> in <code class="docutils literal notranslate"><span class="pre">pelelmex_prob.H</span></code>.</p>
<p>Looking closely at the <code class="docutils literal notranslate"><span class="pre">ProbParm</span></code> struct, we can see that an object specific to
<cite>PeleLMeX</cite> is present, a <code class="docutils literal notranslate"><span class="pre">FlowControllerData</span></code> named <code class="docutils literal notranslate"><span class="pre">FCData</span></code>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>struct ProbParm
{
    amrex::Real P_mean = 101325.0_rt;
    amrex::Real splitx = 0.0;
    amrex::Real midtanh = 0.001;
    amrex::Real widthtanh = 0.001;
    amrex::Real Zst = 0.05;
    amrex::Real T_in = 300.0;
    amrex::Real V_in = 0.4;

    int bathID{-1};
    int fuelID{-1};
    int oxidID{-1};

    FlowControllerData FCData;
};
</pre></div>
</div>
<p>This tutorial will use <cite>PeleLMeX</cite> active control capabilities for which having this object in <code class="docutils literal notranslate"><span class="pre">ProbParm</span></code> is necessary (and checked during initialization).
As the simulation proceeds, the data in that container will be updated and used in <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> to modify the inlet velocity.</p>
</section>
<section id="initial-solution">
<h3>Initial solution<a class="headerlink" href="#initial-solution" title="Link to this heading"></a></h3>
<p>An initial field of the main variables is always required to start a simulation.
Ideally, you want for this initial solution to approximate the final (steady-state in our case) solution as much as possible.
This will speed up the initial transient and avoid many convergence issues.
In the present tutorial, an initial solution is constructed by imposing the same inlet hyperbolic tangent of
mixture fraction than described in subsection <a class="reference internal" href="#sec-tuto-tf-inflowspec"><span class="std std-ref">Problem specifications</span></a> everywhere in the domain,
and reconstructing the species mass fraction profiles from it.
To ensure ignition of the mixture, a progressively widening Gaussian profile of temperature is added,
starting from about 1 cm, and stretching until the outlet of the domain. The initial temperature field is
shown in Fig <a class="reference internal" href="#tf-initialsol"><span class="std std-numref">Fig. 23</span></a>, along with the parameters controlling the shape of the hot spot.</p>
<figure class="align-center" id="tf-initialsol" style="width: 95%">
<img alt="_images/TF_InitialSol.png" src="_images/TF_InitialSol.png" />
<figcaption>
<p><span class="caption-number">Fig. 23 </span><span class="caption-text">: Initial temperature field (left) as well as widening gaussian 1D y-profiles (right) and associated parameters. The initial solution contains 2 levels.</span><a class="headerlink" href="#tf-initialsol" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This initial solution is constructed via the routine <code class="docutils literal notranslate"><span class="pre">pelelmex_initdata()</span></code>, in the file <code class="docutils literal notranslate"><span class="pre">pelelmex_prob.H</span></code>. Additional information is provided as comments in this file for the eager reader, but nothing is required from the user at this point.</p>
</section>
<section id="numerical-scheme">
<h3>Numerical scheme<a class="headerlink" href="#numerical-scheme" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PeleLM</span> <span class="pre">CONTROL</span></code> block contains a few of the <cite>PeleLMeX</cite> algorithmic parameters. Many more
unspecified parameters are relying on their default values which can be found in <a class="reference internal" href="LMeXControls.html"><span class="doc">PeleLMeX controls</span></a>.
Of particular interest are the <code class="docutils literal notranslate"><span class="pre">peleLM.sdc_iterMax</span></code> parameter controlling the number of
SDC iterations (see <a class="reference internal" href="Model.html"><span class="doc">The PeleLMeX Model</span></a> for more details on SDC in <cite>PeleLMeX</cite>) and the
<code class="docutils literal notranslate"><span class="pre">peleLM.num_init_iter</span></code> one controlling the number of initial iteration the solver will do
after initialization to obtain a consistent pressure and velocity field.</p>
</section>
</section>
<section id="building-the-executable">
<h2>Building the executable<a class="headerlink" href="#building-the-executable" title="Link to this heading"></a></h2>
<p>Now that we have reviewed the basic ingredients required to setup the case, it is time to build the <cite>PeleLMeX</cite> executable.
Although both GNUmake and CMake are available, it is advised to use GNUmake. The <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code> file provides some compile-time options
regarding the simulation we want to perform.
The first few lines specify the paths towards the source codes of <cite>PeleLMeX</cite>, <cite>AMReX</cite>, <cite>AMReX-Hydro</cite> and <cite>PelePhysics</cite>, overwriting
any environment variable if necessary, and might have been already updated in <a class="reference internal" href="#sec-tuto-tf-prepstep"><span class="std std-ref">Setting-up your environment</span></a> earlier.</p>
<p>The next few lines specify AMReX compilation options and compiler selection:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span># AMREX
DIM             = 2
DEBUG           = FALSE
PRECISION       = DOUBLE
VERBOSE         = FALSE
TINY_PROFILE    = FALSE

# Compilation
COMP            = gnu
USE_MPI         = TRUE
USE_OMP         = FALSE
USE_CUDA        = FALSE
USE_HIP         = FALSE
USE_SYCL        = FALSE
</pre></div>
</div>
<p>In <cite>PeleLMeX</cite>, the chemistry model (set of species, their thermodynamic and transport properties as well as the
description of their of chemical interactions) is specified at compile time. Chemistry models available
in <cite>PelePhysics</cite> can used in <cite>PeleLMeX</cite> by specifying the name of the folder in <cite>PelePhysics/Mechanisms</cite> containing
the relevant files, for example:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>Chemistry_Model = drm19
</pre></div>
</div>
<p>Here, the methane kinetic model <code class="docutils literal notranslate"><span class="pre">drm19</span></code>, containing 21 species is employed. The user is referred to
the <a class="reference external" href="https://pelephysics.readthedocs.io/en/latest/">PelePhysics</a> documentation for a list of available
mechanisms and more information regarding the EOS, chemistry and transport models specified:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>Eos_Model       := Fuego
Transport_Model := Simple
</pre></div>
</div>
<p>Finally, <cite>PeleLMeX</cite> utilizes the chemical kinetic ODE integrator <a class="reference external" href="https://computing.llnl.gov/projects/sundials/cvode">CVODE</a>. This
Third Party Library (TPL) is shipped as a submodule of the <cite>PeleLMeX</cite> distribution and can be readily installed through the makefile system
of <cite>PeleLMeX</cite>. To do so, type in the following command:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>make TPL
</pre></div>
</div>
<p>Note that the installation of <cite>CVODE</cite> requires CMake 3.23.1 or higher.</p>
<p>You are now ready to build your first <cite>PeleLMeX</cite> executable !! Type in:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>make -j4
</pre></div>
</div>
<p>The option here tells <cite>make</cite> to use up to 4 processors to create the executable
(internally, <cite>make</cite> follows a dependency graph to ensure any required ordering in the build is satisfied).
This step should generate the following file (providing that the build configuration you used matches the one above):</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>PeleLMeX2d.gnu.MPI.ex
</pre></div>
</div>
<p>You’re good to go !</p>
</section>
<section id="initial-transient-phase">
<h2>Initial transient phase<a class="headerlink" href="#initial-transient-phase" title="Link to this heading"></a></h2>
<section id="first-step-the-initial-solution">
<h3>First step: the initial solution<a class="headerlink" href="#first-step-the-initial-solution" title="Link to this heading"></a></h3>
<p>When performing time-dependent numerical simulations, it is good practice to verify the initial solution. To do so,
we will run <cite>PeleLMeX</cite> to perform the initialization only, to generate an initial plotfile <code class="docutils literal notranslate"><span class="pre">plt00000</span></code>.</p>
<p>Time-stepping parameters in <code class="docutils literal notranslate"><span class="pre">input.2d-regt</span></code> are specified in the <code class="docutils literal notranslate"><span class="pre">Time</span> <span class="pre">Stepping</span></code> block:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- Time Stepping CONTROL --------------------
amr.max_step = 0                          # Maximum number of time steps
amr.stop_time = 4.00                      # final simulation physical time
amr.cfl = 0.2                             # CFL number for hyperbolic system
amr.dt_shrink = 0.001                     # Scale back initial timestep
amr.dt_change_max = 1.1                   # Maximum dt increase btw successive steps
</pre></div>
</div>
<p>The maximum number of time steps is set to 0 for now, while the final simulation time is 4.0 s. Note that,
when both <code class="docutils literal notranslate"><span class="pre">max_step</span></code> and <code class="docutils literal notranslate"><span class="pre">stop_time</span></code> are specified, the more stringent constraint will control the
termination of the simulation. <cite>PeleLMeX</cite> solves for the advection, diffusion and reaction processes in time,
but only the advection term is treated explicitly and thus it constrains the maximum time step size
<span class="math notranslate nohighlight">\(dt_{CFL}\)</span>. This constraint is formulated with a classical Courant-Friedrich-Levy (CFL) number,
specified via the keyword <code class="docutils literal notranslate"><span class="pre">amr.cfl</span></code>. Additionally, as it is the case here, the initial solution is often made-up by
the user and local mixture composition and temperature can result in the introduction of unreasonably fast chemical scales.
To ease the numerical integration of this initial transient, the parameter <code class="docutils literal notranslate"><span class="pre">amr.dt_shrink</span></code> allows to shrink the initial <cite>dt</cite>
(evaluated from the CFL constraint) by a factor (usually smaller than 1), and let it relax towards <span class="math notranslate nohighlight">\(dt_{CFL}\)</span> at
a rate given by <code class="docutils literal notranslate"><span class="pre">amr.dt_change_max</span></code> as the simulation proceeds.</p>
<p>Input/output from <cite>PeleLMeX</cite> are specified in the <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">CONTROL</span></code> block:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- IO CONTROL -------------------------------
#amr.restart = chk01000                   # Restart checkpoint file
amr.check_int = 2000                      # Frequency of checkpoint output
amr.plot_int = 20                         # Frequency of pltfile output
amr.derive_plot_vars = avg_pressure mag_vort mass_fractions mixture_fraction progress_variable
</pre></div>
</div>
<p>The first lines (commented out for now) are only used when restarting a simulation from a <cite>checkpoint</cite> file and
will be useful later during this tutorial. Information pertaining to the checkpoint and plot_file files name and output
frequency can be specified there (see <a class="reference internal" href="LMeXControls.html"><span class="doc">PeleLMeX controls</span></a> for a complete list of available keys). <cite>PeleLMeX</cite> will always
generate an initial plotfile <code class="docutils literal notranslate"><span class="pre">plt00000</span></code> if the initialization is properly completed and plotfile IO is triggered,
and a final plotfile at the end of the simulation. It is possible to request including <cite>derived variables</cite> in the plotfiles
by appending their names to the <code class="docutils literal notranslate"><span class="pre">amr.derive_plot_vars</span></code> keyword. These variables are derived from the <cite>state variables</cite>
(velocity, density, temperature, <span class="math notranslate nohighlight">\(\rho Y_k\)</span>, <span class="math notranslate nohighlight">\(\rho h\)</span>) which are automatically included in the plotfile.</p>
<p>You finally have all the information necessary to run the first of several steps to generate a steady triple flame. Type in:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>./PeleLMeX2d.gnu.MPI.ex input.2d-regt
</pre></div>
</div>
<p>If you wish to store the standard output of <cite>PeleLMeX</cite> for later analysis, you can instead use:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>./PeleLMeX2d.gnu.MPI.ex input.2d-regt &gt; logCheckInitialSolution.dat &amp;
</pre></div>
</div>
<p>Whether you have used one or the other command, within 10 s you should obtain a <code class="docutils literal notranslate"><span class="pre">plt00000</span></code> file (or even more,
appended with .old*********** if you used both commands). Use <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Visualization.html">Amrvis</a>
to visualize <code class="docutils literal notranslate"><span class="pre">plt00000</span></code> and make sure the solution matches the one shown in Fig. <a class="reference internal" href="#tf-initialsol"><span class="std std-numref">Fig. 23</span></a>.</p>
</section>
<section id="running-the-problem-on-a-coarse-grid">
<h3>Running the problem on a coarse grid<a class="headerlink" href="#running-the-problem-on-a-coarse-grid" title="Link to this heading"></a></h3>
<p>As mentioned above, the initial solution is relatively far from the steady-state triple flame we wish to obtain.
An inexpensive and rapid way to transition from the initial solution to an established triple flame is to perform
a coarse (using only 2 AMR levels) simulation using a single SDC iteration for a few initial number of time steps
(here we start with 1000). To do so, update (or verify !) these associated keywords in the <code class="docutils literal notranslate"><span class="pre">input.2d-regt</span></code>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="gh">#---------------------- AMR CONTROL ------------------------------</span>
<span class="gh">...</span>
<span class="gh">amr.max_level         = 1                 # maximum level number allowed</span>
<span class="gh">...</span>
<span class="gh">#---------------------- Time Stepping CONTROL --------------------</span>
<span class="gh">...</span>
<span class="gh">amr.max_step          = 1000              # maximum number of time steps</span>
<span class="gh">...</span>
<span class="gh">#---------------------- PeleLM CONTROL ---------------------------</span>
<span class="gh">...</span>
peleLM.sdc_iterMax    = 1                 # Number of SDC iterations
</pre></div>
</div>
<p>To be able to complete this first step relatively quickly, it is advised to run <cite>PeleLM</cite> using at least 4 MPI processes if possible.
It will then take around 10 mn to reach completion. To be able to monitor the simulation while it is running, use the following command:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>mpirun -n 4 ./PeleLMeX2d.gnu.MPI.ex input.2d-regt &gt; logCheckInitialTransient.dat &amp;
</pre></div>
</div>
<p>A plotfile is generated every 20 time steps (as specified via the <code class="docutils literal notranslate"><span class="pre">amr.plot_int</span></code> keyword in the <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">CONTROL</span></code> block). This will
allow you to visualize and monitor the evolution of the flame. Use the following command to open multiple plotfiles at once
with <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Visualization.html">Amrvis</a>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>amrvis -a plt????0
</pre></div>
</div>
<p>An animation of the flame evolution during the entire tutorial, including this initial transient, is provided in <a class="reference internal" href="#tf-inittransient"><span class="std std-numref">Fig. 24</span></a>.</p>
<figure class="align-center" id="tf-inittransient" style="width: 95%">
<img alt="_images/TF_Transient.gif" src="_images/TF_Transient.gif" />
<figcaption>
<p><span class="caption-number">Fig. 24 </span><span class="caption-text">: Temperature (left) and divu (right) fields from 0 to 2000 time steps (0-?? ms).</span><a class="headerlink" href="#tf-inittransient" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="steady-state-problem-activating-the-flame-control">
<h3>Steady-state problem: activating the flame control<a class="headerlink" href="#steady-state-problem-activating-the-flame-control" title="Link to this heading"></a></h3>
<p>The speed of propagation of a triple flame is not easy to determine a-priori. As such it is useful,
at least until the flame settles, to have some sort of stabilization mechanism to prevent
flame blow-off or flashback. In the present configuration, the position of the flame front can be tracked
at each time step (using an isoline of temperature) and the input velocity is adjusted to maintain
its location at a fixed distance from the inlet (1 cm in the present case).</p>
<p>The parameters of the active control are listed in <cite>AC CONTROL</cite> block of <code class="docutils literal notranslate"><span class="pre">input.2d-regt</span></code>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- AC CONTROL -------------------------------
active_control.on = 1                     # Use AC ?
active_control.use_temp = 1               # Default in fuel mass, rather use iso-T position ?
active_control.temperature = 1400.0       # Value of iso-T ?
active_control.tau = 1.0e-4               # Control tau (should ~ 10 dt)
active_control.height = 0.01              # Where is the flame held ? Default assumes coordinate along Y in 2D or Z in 3D.
active_control.v = 1                      # verbose
active_control.velMax = 2.0               # Optional: limit inlet velocity
active_control.changeMax = 0.1            # Optional: limit inlet velocity changes (absolute m/s)
active_control.flow_dir  = 1              # Optional: flame main direction. Default: AMREX_SPACEDIM-1
active_control.pseudo_gravity = 1         # Optional: add density proportional force to compensate for the acceleration
                                          #           of the gas due to inlet velocity changes
</pre></div>
</div>
<p>The first keyword activates the active control and the second one specify that the flame will be tracked
based on an iso-line of temperature, the value of which is provided in the third keyword. The following parameters
control the relaxation of the inlet velocity to the steady state velocity of the triple flame. <code class="docutils literal notranslate"><span class="pre">tau</span></code> is a relaxation time scale,
that should be of the order of ten times the simulation time-step. <code class="docutils literal notranslate"><span class="pre">height</span></code> is the user-defined location where the
triple flame should settle, <code class="docutils literal notranslate"><span class="pre">changeMax</span></code> and <code class="docutils literal notranslate"><span class="pre">velMax</span></code> control the maximum velocity increment and maximum inlet velocity, respectively.
The user is referred to <a class="reference internal" href="#camcs2006" id="id4"><span>[CAMCS2006]</span></a> for an overview of the method and corresponding parameters.
The <code class="docutils literal notranslate"><span class="pre">pseudo_gravity</span></code> triggers a manufactured force added to the momentum equation to compensate for the acceleration of different density gases.</p>
<p>Once these parameters are set, you continue the previous simulation by uncommenting the first line of the <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">CONTROL</span></code> block in the input file:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>amr.restart           = chk01000 # Restart checkpoint file
</pre></div>
</div>
<p>On this line, provide the last <cite>checkpoint</cite> file generated during the first simulation performed for 1000 time steps.
Finally, update the <code class="docutils literal notranslate"><span class="pre">amr.max_step</span></code> to allow the simulation to proceed further:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="gh">#---------------------- Time Stepping CONTROL --------------------</span>
<span class="gh">...</span>
amr.max_step          = 2000          # maximum number of time steps
</pre></div>
</div>
<p>You are now ready launch <cite>PeleLMeX</cite> again for another 1000 time steps !</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>mpirun -n 4 ./PeleLMeX2d.gnu.MPI.ex inputs.2d-regt &gt; logCheckControl.dat &amp;
</pre></div>
</div>
<p>As the simulation proceeds, an ASCII file tracking the flame position and inlet velocity
(as well as other control variables) is generated: <code class="docutils literal notranslate"><span class="pre">AC_History</span></code>. You can follow the motion of
the flame tip by plotting the seventh column against the first one (flame tip vs. time step count).
If <cite>gnuplot</cite> is available on your computer, use the following to obtain the graphs of <a class="reference internal" href="#tf-accontrol"><span class="std std-numref">Fig. 25</span></a>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>gnuplot
plot &quot;AC_History.dat&quot; u 1:7 w lp
plot &quot;AC_History.dat&quot; u 1:3 w lp
exit
</pre></div>
</div>
<p>The second plot corresponds to the inlet velocity.</p>
<figure class="align-center" id="tf-accontrol" style="width: 95%">
<img alt="_images/TF_ACcontrol.png" src="_images/TF_ACcontrol.png" />
<figcaption>
<p><span class="caption-number">Fig. 25 </span><span class="caption-text">: Flame tip position (left) and inlet velocity (right) as function of time step count from 1000 to 2000 step using the inlet velocity control.</span><a class="headerlink" href="#tf-accontrol" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>At this point, you have a stabilized methane/air triple flame and will now use AMR features to improve the quality of your simulation.</p>
</section>
</section>
<section id="refinement-of-the-computation">
<h2>Refinement of the computation<a class="headerlink" href="#refinement-of-the-computation" title="Link to this heading"></a></h2>
<p>Before going further, it is important to look at the results of the current simulation. The left panel of <a class="reference internal" href="#tf-coarsedetails"><span class="std std-numref">Fig. 26</span></a>
displays the temperature field, while a zoom-in of the flame edge region colored by several important variables
is provided on the right side.
Note that <cite>DivU</cite>, the <cite>HeatRelease</cite> and the <cite>CH4_consumption</cite> are good markers of the reaction/diffusion processes in our case.
What is striking from these images is the lack of resolution of the triple flame, particularly in the reaction zone.
We also clearly see square unsmooth shapes in the field of intermediate species, where <cite>Y(HCO)</cite> is found to
closely match the region of high <cite>CH4_consumption</cite> while <cite>Y(CH3O)</cite> is located closer to the cold gases, on the outer layer of the triple flame.</p>
<figure class="align-center" id="tf-coarsedetails" style="width: 95%">
<img alt="_images/TF_CoarseDetails.png" src="_images/TF_CoarseDetails.png" />
<figcaption>
<p><span class="caption-number">Fig. 26 </span><span class="caption-text">: Details of the triple flame tip obtained with the initial coarse 2-level mesh.</span><a class="headerlink" href="#tf-coarsedetails" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Our additional level of refinement must specifically target the reactive layer of the flame. As seen
from <a class="reference internal" href="#tf-coarsedetails"><span class="std std-numref">Fig. 26</span></a>, one can choose from several variables to reach that goal. In the following,
we will use the CH3O species as a tracer of the flame position. Start by increasing the number of AMR levels by one
in the <cite>AMR CONTROL</cite> block:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="gh">#---------------------- AMR CONTROL ------------------------------</span>
<span class="gh">...</span>
amr.max_level       = 2          # maximum level number allowed
</pre></div>
</div>
<p>Then provide a definition of the new refinement criteria in the <cite>Refinement CONTROL</cite> block:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>#---------------------- Refinement CONTROL------------------------
amr.refinement_indicators = highT gradT flame_tracer   # Declare set of refinement indicators

amr.highT.max_level     = 1
amr.highT.value_greater = 800
amr.highT.field_name    = temp

amr.gradT.max_level                   = 1
amr.gradT.adjacent_difference_greater = 200
amr.gradT.field_name                  = temp

amr.flame_tracer.max_level     = 2
amr.flame_tracer.value_greater = 1.0e-6
amr.flame_tracer.field_name    = Y(CH3O)
</pre></div>
</div>
<p>The first line simply declares a set of refinement indicators which are subsequently defined. For each indicator,
users can provide a limit up to which AMR level this indicator will be used to refine. Then there are multiple possibilities
to specify the actual criterion: <code class="docutils literal notranslate"><span class="pre">value_greater</span></code>, <code class="docutils literal notranslate"><span class="pre">value_less</span></code>, <code class="docutils literal notranslate"><span class="pre">vorticity_greater</span></code> or <code class="docutils literal notranslate"><span class="pre">adjacent_difference_greater</span></code>.
In each case, the user specify a threshold value and the name of variable on which it applies (except for the <code class="docutils literal notranslate"><span class="pre">vorticity_greater</span></code>).
In the example above, the grid is refined up to level 1 at the location wheres the temperature is above 800 K or where the temperature
difference between adjacent cells exceed 200 K. These two criteria were used up to that point. The last indicator will now enable
to add level 2 grid patches at location where the flame tracer (<cite>Y(CH3O)</cite>) is above 1.0e-6.</p>
<p>With these new parameters, update the <cite>checkpoint</cite> file from which to restart:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>amr.restart           = chk02000 # Restart checkpoint file
</pre></div>
</div>
<p>and increase the <code class="docutils literal notranslate"><span class="pre">amr.max_step</span></code> to 2500 and start the simulation again !</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>mpirun -n 4 ./PeleLMeX2d.gnu.MPI.ex input.2d-regt &gt; log3Levels.dat &amp;
</pre></div>
</div>
<p>Visualization of the 3-levels simulation results indicates that the flame front is now better represented on the fine grid,
but there are still only a couple of cells across the flame front thickness. The flame tip velocity, captured in the <cite>AC_history</cite>, also
exhibits a significant change with the addition of the third level (even past the initial transient). In the present case,
the flame tip velocity is our main quantity of interest and we will now add another refinement level to ensure that this quantity
is fairly well captured. We will use the same refinement indicators and simply update the <code class="docutils literal notranslate"><span class="pre">amr.max_level</span></code> as well as the level
at which each refinement criteria is used:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>amr.max_level         = 3          # maximum level number allowed

<span class="cp">...</span>

amr.restart           = chk02300 # Restart from checkpoint ?

<span class="cp">...</span>

amr.gradT.max_level   = 2

<span class="cp">...</span>

amr.flame_tracer.max_level  = 3
</pre></div>
</div>
<p>and increase the <code class="docutils literal notranslate"><span class="pre">amr.max_step</span></code> to 3000. Within <cite>PeleLMeX</cite> non-subcycling time advance, the step size is decreasing as we increase the number of AMR
levels. We started with a rather small CFL number of 0.2 to avoid numerical issues associated with coarse simulations and large time step size
(see <a class="reference internal" href="Tutorials_BFSFlame.html"><span class="doc">Backward facing step anchored premixed flame</span></a> more a practical example of integration failure). Additionally, as our step size decreases, the <cite>tau</cite> parameter of the
active control becomes comparatively larger, resulting in slower response of the adapted inlet velocity to flame position changes. Let’s increase the
CFL number of 0.3, reduce <cite>tau</cite> and add a second SDC iteration to tighten the coupling between the various processes:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>peleLM.sdc_iterMax = 2

<span class="cp">...</span>

amr.cfl = 0.3

<span class="cp">...</span>

active_control.tau = 1.0e-4            # Control tau (should ~ 10 dt)
</pre></div>
</div>
<p>Let’s start the simulation again !</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>mpirun -n 4 ./PeleLM2d.gnu.MPI.ex inputs.2d-regt &gt; log4Levels.dat &amp;
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tf-accomplete"><span class="std std-numref">Fig. 27</span></a> shows the entire history of the inlet velocity starting when
the AC was activated (1000th time step). We can see that every change in the numerical setup induced a slight change in the
triple flame propagation velocity, eventually leading to a nearly constant value, sufficient for the purpose of this tutorial.</p>
<figure class="align-center" id="tf-accomplete" style="width: 95%">
<img alt="_images/TF_ACcomplete.png" src="_images/TF_ACcomplete.png" />
<figcaption>
<p><span class="caption-number">Fig. 27 </span><span class="caption-text">: Inlet velocity history during the successive simulations performed during this tutorial.</span><a class="headerlink" href="#tf-accomplete" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>At this point, the simulation is considered complete.</p>
<div role="list" class="citation-list">
<div class="citation" id="pci2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">PCI2007</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="19">
<li><p>Chung, Stabilization, propagation and instability of tribrachial triple flames, Proceedings of the Combustion Institute 31 (2007) 877–892</p></li>
</ol>
</div>
<div class="citation" id="cf1990" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">CF1990</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="18">
<li><p>Bilger, S. Starner, R. Kee, On reduced mechanisms for methane-air combustion in nonpremixed flames, Combustion and Flames 80 (1990) 135-149</p></li>
</ol>
</div>
<div class="citation" id="camcs2006" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">CAMCS2006</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="10">
<li><p>Bell, M. Day, J. Grcar, M. Lijewski, Active Control for Statistically Stationary Turbulent PremixedFlame Simulations, Communications in Applied Mathematics and Computational Science 1 (2006) 29-51</p></li>
</ol>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Tutorials_BFSFlame.html" class="btn btn-neutral float-left" title="Backward facing step anchored premixed flame" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, PeleTeam.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>